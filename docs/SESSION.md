# 세션(락스텝) 이해하기 (학습용)

원격 1:1 멀티플레이를 위해 이 프로젝트는 “P2P Lockstep”을 사용합니다. 핵심은 두 참가자가 같은 틱에 같은 입력을 적용하며 같은 결정론 코어를 실행한다는 점입니다.

**핵심 용어**
- 틱(Tick): 고정 시간 단위로 진행되는 로직 스텝. `TICKS_PER_SECOND=60`.
- 입력 비트마스크: 한 틱에서의 버튼 상태를 `uint8_t` 비트로 표현.
- 입력 지연(Input Delay): 네트워크 지연을 흡수하기 위해 일부 틱만큼 입력을 유예.
- 안전 틱(Safe Tick): 양쪽 모두 입력이 도착한 마지막 틱. 여기까지는 안심하고 시뮬레이션을 진행.
- 세션 시드(Seed): RNG 초기값. 모두 같아야 같은 블록 순서를 보장.

**결정론 전제**
- 고정 틱으로만 시간 진행
- 틱별 입력만으로 상태 변경
- 같은 시드/같은 호출 순서의 RNG
- 동일 코드(플랫폼 차이 없는 연산)

**핸드셰이크**
- HELLO: 프로토콜 버전 등 간단 인사.
- SEED: `seed:u64, start_tick:u32, input_delay:u8, role:u8` 배포.
  - start_tick은 시작까지의 유예 틱 수(카운트다운 느낌).
  - input_delay는 수신 입력을 기다릴 틱 버퍼 용도.

**메시지와 프레이밍**
- 프레임 포맷은 `docs/FRAMING.md` 참고.
- 메시지 타입
  - HELLO, HELLO_ACK
  - SEED
  - INPUT: `from_tick:u32, count:u16, inputs[count]:u8`
  - ACK: `up_to_tick:u32` (학습용 단순 확인)
  - PING/PONG: 왕복 시간 측정용(후속 활용)

**스레딩 모델**
- 메인 스레드
  - 입력 샘플링 → 로컬 입력 전송 요청
  - 수신 큐에서 틱 입력 조회 → 병합(OR) → `SubmitInput` → `Tick`
  - 안전 틱 이내에서만 진행(미도착이면 대기)
- I/O 스레드
  - 소켓에서 바이트 수신 → 프레이밍 파싱 → 프레임 처리
  - 송신 큐의 프레임을 소켓으로 전송

**데이터 흐름**
- 로컬 입력 생성 → INPUT 전송
- 원격 INPUT 수신 → 틱→입력 맵 저장
- 메인 루프에서 해당 틱의 원격 입력 존재 여부를 확인
- 둘 다 있으면 병합하여 결정론 코어에 적용하고 틱 진행

**시작/시간 관리**
- start_tick 만큼 카운트다운 후 진행
- input_delay를 두어 RTT/2~RTT 정도의 네트워크 지연을 흡수
- 필요 시 작은 속도 보정으로 드리프트를 수렴(심화)

**무결성/신뢰성**
- TCP를 사용하여 기본 순서/신뢰 보장
- 페이로드 FNV-1a 체크로 간단 무결성 확인(학습용)
- ACK는 학습용으로 up_to_tick 통지만 제공(재전송 정책은 후속)

**desync 탐지/복구(계획)**
- 상태 해시: `Game::ComputeStateHash()` 값을 주기적으로 교환하여 불일치 감지
- 스냅샷/델타: 상태 직렬화로 재동기
- 리플레이: 시드+입력 로그로 재현/디버깅

**로비/매치메이킹(계획)**
- 방 코드 기반 합류와 큐 기반 매칭을 로비 서버에서 처리
- 로비가 시드/시작틱/입력지연/역할을 결정하여 양측에 통지
- 이후 P2P 연결에서 이 세션 문서를 따라 진행

**파라미터 가이드**
- TICKS_PER_SECOND: 60을 권장(부동 연산 오차와 렌더와의 분리)
- input_delay: 초기 3~6틱, RTT/지터를 고려해 조정
- start_tick: 접속/준비를 위한 여유(예: 120틱)

**테스트 팁**
- localhost에서 두 프로세스로 실행하여 입력 동기와 진행 확인
- 인위 지연/지터/유실을 I/O에 삽입해 복원력 시험(후속 구현)
- 상태 해시 로그를 비교하여 결정론 위반 지점 파악

**확장 경로**
- 전송층을 Asio로 교체하여 비동기/타이머/크로스플랫폼 안정화
- ENet(UDP 신뢰층)으로 이동하여 저지연/패킷 제어 심화
- 롤백(GGPO 스타일)로 체감 지연 감소(스냅샷/되감기/재적용)

