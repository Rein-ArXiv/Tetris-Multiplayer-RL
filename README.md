# C++와 Raylib로 만든 테트리스

## Windows 빌드 방법 (w64devkit + raylib)

- 준비물
  - raylib 공식 Windows 배포본 설치: `C:/raylib` 폴더에 w64devkit과 raylib 소스가 있다고 가정합니다.
  - `C:/raylib/w64devkit/w64devkit.exe`로 셸을 실행하면 컴파일러 PATH가 자동 설정됩니다.

- 빌드
  - 프로젝트 루트에서 아래 명령을 실행하세요.
    - `mingw32-make PLATFORM=PLATFORM_DESKTOP RAYLIB_PATH=C:/raylib/raylib`
  - 빌드가 성공하면 루트 디렉터리에 `tetris.exe`가 생성됩니다.

- 실행
  - `tetris.exe`를 프로젝트 루트(리소스 경로 유지)에서 실행하세요.
  - 필요 시 `lib/libstdc++-6.dll`, `lib/libgcc_s_dw2-1.dll`을 실행 파일과 같은 폴더에 두거나 PATH에 w64devkit을 추가하세요.

참고: VS Code를 사용할 경우 `.vscode/tasks.json`의 "build release" 또는 F5(런) 구성을 사용하면 자동으로 빌드/실행이 가능합니다.

## Linux 빌드 방법 (CMake)

- 전제: raylib가 시스템에 설치되어 있어야 합니다. 예) Homebrew/Linuxbrew 또는 `make install`로 `/usr/local`에 설치
- 빌드
  - `mkdir -p build && cd build`
  - `cmake ..` (pkg-config가 raylib을 찾으면 자동 연결, 그 외엔 `/usr/local` 기본 경로 사용)
  - `cmake --build . -j`
  - 실행: `./tetris`

## 멀티플레이 준비 1단계(이미 반영됨)
- 결정론 틱 기반 로직 도입: 고정 60Hz 틱, 입력은 틱 단위 비트마스크로 처리
- 자체 PRNG(XorShift64*)로 RNG 결정론화, 시드 기반 재현 가능
- 리플레이/네트코드 확장을 위한 입력 샘플링 경로 분리(`SubmitInput`, `Tick`)

이후 단계에서 P2P Lockstep 또는 서버 권위 모델을 점진적으로 추가할 수 있습니다.
**프로젝트 구조**
- `src/` 게임 렌더링/오디오/입력(raylib 의존)
- `core/` 결정론 코어(틱, 입력 비트마스크, RNG, 해시, 리플레이)
- `Font/`, `Sounds/` 리소스 폴더
- `CMakeLists.txt` Linux/Windows 공용 빌드 스크립트
- `Makefile` w64devkit 환경에 맞춘 Windows 빌드 스크립트

**조작/핫키**
- 이동/회전: `←/→/↓/↑`
- 하드드롭: `Space`
- 리스타트: 게임오버 화면에서 임의 키
- 리플레이 기록 시작/저장: `F5` 시작, `F6` 저장(`out/replay.txt`)
- 상태 해시 출력: `H` (콘솔 출력)

**결정론 코어 개념**
- 고정 틱(`TICKS_PER_SECOND = 60`): 모든 로직은 틱 단위로만 진행합니다.
- 입력 비트마스크(`core/input.h`): 매 틱의 입력을 바이트로 표현(`LEFT/RIGHT/DOWN/ROTATE/DROP`).
- RNG 결정론화(`core/rng.h`): `XorShift64*` 사용, 세션 시드가 같으면 동일한 블록 순서.
- 상태 해시(`Game::ComputeStateHash`): 그리드/블록/RNG/점수/중력을 FNV-1a 64비트로 해싱.
- 리플레이(`core/replay.*`): 텍스트 기반 `seed/ticks/p1 p2` 입력 기록/로드.

**핵심 API 요약**
- `Game::SubmitInput(uint8_t mask)`: 한 틱의 입력(로컬/원격 합산)을 적용.
- `Game::Tick()`: 시간을 1틱 진행(중력/낙하). Lockstep에선 모든 참가자 입력 수신 후 호출.
- `Game::ComputeStateHash()`: 현재 상태를 64비트 해시로 반환.
- `XorShift64Star`: `next()`, `nextUInt(max)`, `getState()` 제공. 세션 시드로 초기화 필요.
- 상수/입력 정의: `core/constants.h`, `core/input.h`.

**네트워킹 로드맵(학습 중심)**
- 로컬 2P(한 프로세스): 동일 시드로 `Game` 두 개 운용, 보드 나란히 렌더, 해시로 동기 검증.
- Lockstep 스캐폴딩: HELLO/SEED/START/INPUT/ACK, 입력 지연 버퍼, 안전 틱 경계. TCP부터.
- 스냅샷/복구: 주기 스냅샷과 해시 비교로 desync 시 재동기.
- 서버 권위(옵션): 시드/시작틱/스냅샷 배포, 관전자/재접속.

**원격 1:1 빠른 시작(실험용)**
- 호스트: `./tetris --host 7777`
- 피어: `./tetris --connect <host_ip>:7777`
- 현재 동작
  - TCP로 연결 → HELLO/SEED 교환 → 입력을 틱 단위로 교환 → 안전하게 진행
  - HUD 하단에 네트 상태가 간단 출력됩니다.
- 주의: 초기 버전은 입력 지연/재전송/스냅샷이 최소화되어 있으며, 학습 목적으로 단순화되어 있습니다.

**멀티플레이 UX(계획)**
- 메인 메뉴: Single / Multiplayer
- Multiplayer: Quick Match(매치메이킹) / Create Room(방 코드 표시) / Join Room(코드 입력)
- 로비 서버(간단 TCP): 방 생성/참가/큐 매칭/파라미터 배포 → P2P 연결 시작

**To‑Do**
- 로컬 2P + 보드 렌더 오프셋, P1/P2 키 바인딩 분리
- 리플레이 재생기(자동 재생/검증)
- 상태 스냅샷 직렬화/역직렬화
- 네트워크 입력 큐/세션(입력 지연, ACK, 타임아웃) 스캐폴딩
- TCP 전송층(Windows/Linux) → localhost 2프로세스 테스트
- 가비지 규칙 훅 연결(라인 클리어 시 전송)
- 상태 해시 로그/비교 도구

**FAQ**
- 같은 시드를 쓰면 블록 순서가 항상 같나요? → 네. 다만 방마다 새로운 시드를 생성해 매번 다르게 구성하는 게 일반적입니다.
- Linux 지원이 복잡한가요? → CMake로 빌드 가능하며 TCP부터 시작하면 플랫폼 차이는 작습니다.

**문제 해결**
- 리소스 경로: 실행 디렉터리를 프로젝트 루트로.
- Windows DLL 누락: `lib/libstdc++-6.dll`, `lib/libgcc_s_dw2-1.dll`을 exe 옆 또는 PATH에 추가.
- raylib 링크 실패(Linux): `pkg-config raylib` 확인, `/usr/local` 설치 또는 CMake에 경로 지정.

## 네트워크 개념 정리(이 구현과의 연관)

아래 개념들은 본 프로젝트가 채택한 “결정론 틱 + 입력 동기화” 설계와 직접 연결됩니다. 학습용으로 핵심만 요약합니다.

### 아키텍처 모델
- 클라이언트/서버(서버 권위): 치팅 억제, 재접속/관전자/스냅샷 배포 용이. 서버 구현/호스팅 필요.
- P2P Lockstep(결정론 동기): 입력만 교환해 대역폭 적음. 지연=입력지연로 체감. 치팅 취약.
- P2P Rollback(예측/되감기): 지연 체감 낮음. 상태 스냅샷/되감기/재적용이 필요해 복잡.

### 시간/동기화
- 고정 틱(Fixed Timestep): `TICKS_PER_SECOND=60` 같은 공통 기준으로 로직 실행. 렌더와 분리.
- 시작 틱/세션 시드 합의: HELLO/SEED/START로 동일한 시작점 보장.
- 시계 드리프트: 네트 틱과 시뮬레이션 틱을 분리하거나 보정(작은 가감속)으로 수렴.

### 지연/지터/패킷 유실 대응
- 입력 지연 버퍼(Input Delay): RTT 일부만큼 유예 후 ‘안전 틱’까지 진행.
- 재전송/ACK: 입력 패킷은 누락되면 재전송. 누적 ACK 또는 선택적 ACK 사용.
- 타임아웃/재연결: 일정 틱 이상 미수신 시 일시 정지/재접속 절차.

### 신뢰성/순서 보장
- TCP: 순서/신뢰 보장, 구현 단순. HOL 블로킹 영향 존재.
- UDP(+ARQ): 시퀀스 번호, ACK 비트필드(Selective Repeat), 재전송/중복 제거 구현 필요.
- 메시지 ID/틱 번호: 재정렬/중복제거/멱등 처리를 위해 필수 메타데이터.

### 패킷/직렬화
- 길이 프리픽스 + 타입 헤더 + 페이로드 + CRC/해시(FNV-1a 등)로 간단한 바이너리 프로토콜.
- 엔디안/정렬: 리틀엔디안 고정, 고정 폭 정수 사용(`uint8/16/32`), 패딩 주의.
- 입력 압축: 연속 틱 범위를 묶거나 런-렝스, 비트패킹으로 대역폭 절감.

### 상태 동기화/복구
- 상태 해시(본 프로젝트: `Game::ComputeStateHash()`): 틱별로 비교해 desync 즉시 검출.
- 스냅샷/델타: 주기적 전체 스냅샷 또는 델타를 보내 재동기화.
- 리플레이: 시드+틱 입력만으로 재현. 디버깅/재현성 검증에 핵심.

### 입력 동기화(락스텝)와 롤백
- Lockstep: 틱 N의 모든 입력을 모은 뒤 1회 진행 → 결정론 보장.
- Rollback: 예측으로 진행 후 원본 입력 도착 시 해당 틱으로 되감아 다시 시뮬레이션.
- 결정론 전제: 고정 틱/순수 로직/RNG 시드/호출 순서 고정이 필수.

### RNG/시드 운용
- 세션 시드: 방/매치마다 새로 생성해 매번 다른 시퀀스.
- RNG 스트림 분리: 블록 RNG와 가비지 RNG를 분리해 소비 순서 간섭 제거.
- 가방 셔플(Fisher–Yates): 가방 인덱스 기반으로 독립 셔플 시 랜덤 접근 가능.

### 보안/치팅/권한
- 서버 권위: 상태 변경은 서버에서 검증/적용. 클라이언트는 입력만 전송.
- 입력 무결성: 서명/해시로 위·변조 탐지(학습 단계에선 로그/해시 비교부터).
- 속도핵/타임워프: 서버 기준 틱/속도로 판정, 비정상 패턴 거부/제재.

### NAT/연결성
- TCP: 대체로 문제 적음. UDP P2P는 NAT 홀펀칭/STUN/릴레이 고려.
- 포트 선택/Keepalive: 유휴 연결 유지, 방화벽 타임아웃 회피.

### 성능/대역폭/프레이밍
- 네트 틱(예: 20~30Hz)과 시뮬 틱(60Hz) 분리 가능. 입력을 묶어 전송.
- Nagle/Delayed ACK: 저지연이 중요하면 비활성 고려(TCP_NODELAY).
- MTU/분할: UDP는 1200바이트 내 패킷 유지 권장. 조각화 회피.

### 스레딩/동시성(클라이언트)
- 메인 스레드: 렌더/오디오/입력 샘플링.
- 네트 스레드: 소켓 I/O, 패킷 파싱 → lock-free 큐/뮤텍스로 메인과 교환.
- 데이터 경합: 프레임 스냅샷/이중 버퍼로 렌더-시뮬레이션 분리.

### 디버깅/계측
- 해시/로그: 틱별 입력/해시 기록 비교.
- 네트 조건 시뮬레이터: 지연/지터/유실/중복 삽입기로 회복력 테스트.
- 리플레이 우선: 버그 재현성 확보가 생산성의 핵심.
