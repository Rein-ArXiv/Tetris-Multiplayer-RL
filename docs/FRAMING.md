# 메시지 프레이밍 이해하기 (학습용)

이 프로젝트는 TCP 스트림 위에 아주 단순한 프레이밍을 올려, 메시지 경계를 복원하고 무결성(간단 해시)만 확인합니다.

## 바이트 레이아웃(리틀엔디안)

```
[LEN: u16][TYPE: u8][PAYLOAD: (LEN-1) bytes][CHK: u32]
```

- `LEN`에는 `TYPE(1바이트)+PAYLOAD(N바이트)`의 합이 들어갑니다.
- `CHK`는 `PAYLOAD`에 대한 FNV-1a 32비트 해시입니다(학습용 간단 체크).
- TCP는 스트림이므로, 여러 프레임이 붙어서 오거나 하나의 프레임이 조각나서 올 수 있습니다.

## 왜 이런 형태를 쓰나요?

- 길이 프리픽스(u16)로 “이번 메시지에 필요한 총 바이트 수”를 미리 알 수 있어 재조립이 쉽습니다.
- 타입(u8)으로 메시지 종류(HELLO/SEED/INPUT 등)를 식별합니다.
- 체크섬(FNV-1a 32)으로 간단한 데이터 손상/프레이밍 오류를 감지합니다.

## 송신: build_frame()

1. `LEN = 1(TYPE) + payload.size()`를 계산
2. `[LEN][TYPE][PAYLOAD]` 순서로 바이트를 채움
3. `CHK = FNV-1a32(PAYLOAD)`를 뒤에 붙임

코드: `net/framing.cpp`의 `build_frame()`

## 수신: parse_frames()

1. 누적 버퍼에 2바이트 이상 쌓였는지 확인 → `LEN` 읽기
2. `LEN_FIELD(2) + LEN + CHECKSUM(4)` 만큼 바이트가 도착했는지 확인
3. `TYPE`, `PAYLOAD` 위치 계산
4. `CHK`를 읽고 `FNV-1a32(PAYLOAD)`와 비교(일치하면 프레임 유효)
5. 유효 프레임을 `Frame{type, payload}`로 out에 추가
6. 소비한 바이트를 버퍼에서 제거, 나머지 조각 데이터는 유지

코드: `net/framing.cpp`의 `parse_frames()`

## 흔한 함정과 팁

- 스트림 특성: `recv()`는 원하는 길이만큼 항상 주지 않습니다(부분 수신/여러 프레임 합쳐짐). 반드시 누적 버퍼로 처리하세요.
- 엔디안: 네트워크 전송은 보통 빅엔디안을 쓰지만, 여기서는 “내부 통일” 목적의 리틀엔디안을 채택했습니다(양쪽 동일 구현 전제). 교차 환경에선 명시적 변환.
- 무결성: FNV-1a 32는 가벼운 체크입니다. 실전에서는 CRC32C, HMAC 등 보강을 검토하세요.
- 확장: `LEN`을 `u32`로 키우거나, 헤더에 시퀀스/틱 번호를 추가하는 식으로 발전시킬 수 있습니다.

## 다음 학습 단계

- 선택적 ACK 비트필드(예: 32틱 창을 한 패킷으로 ACK)
- 메시지 합치기/패킷화 정책(네트 틱과 묶어서 전송)
- PING/PONG으로 RTT/지터 측정해 입력 지연 동적 조정
- 스냅샷/델타 프레이밍(상태 직렬화 구조 설계)

